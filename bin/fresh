#!/bin/bash

## Exit immediately if a command exits with a non-zero status
set -e

## Enables pattern lists like @(init|start|stop)
## Credit: http://stackoverflow.com/a/13254908
shopt -s extglob

## Init
init_variables() {
  VAR_DIR="${HOME}/.fresh"
  VAR_VALID_COMMANDS="@(install|undo|init)"
  VAR_VALID_ARGUMENTS="@(version|help)"
  VAR_VALID_COMMAND_ARGUMENTS="@(skip)"
  VAR_RECAP_ARRAY=()

  ## Symbols
  VAR_SYMBOL_ERROR="x"
  VAR_SYMBOL_PASS="âœ“"
  VAR_SYMBOL_WARN="!"
  VAR_SYMBOL_INFO="*"

  ## Colours
  VAR_COLOUR_PASS=$(tput setaf 2)
  VAR_COLOUR_INFO=$(tput setaf 4)
  VAR_COLOUR_WARN=$(tput setaf 3)
  VAR_COLOUR_ERROR=$(tput setaf 1)
  VAR_COLOUR_LOGO_TOP=$(tput setaf 6)
  VAR_COLOUR_LOGO_MID=$(tput setaf 12)
  VAR_COLOUR_LOGO_BTM=$(tput setaf 4)
  VAR_COLOUR_RESET=$(tput sgr0)
}

init_fresh() {
  init_variables

  ## Very gradient such ascii wow
  ## Credit: http://patorjk.com/software/taag/#p=display&h=2&v=0&c=echo&f=Chunky&t=FRESH
  echo
  print_logo "TOP" " _______ ______ _______ _______ _______ ";
  print_logo "MID" "|    ___|   __ \    ___|     __|   |   |";
  print_logo "MID" "|    ___|      <    ___|__     |       |";
  print_logo "BTM" "|___|   |___|__|_______|_______|___|___|";
  echo

  ## Quick compatability check
  if [[ $(uname) != "Darwin" ]]; then
    print_status_primary "ERROR" "ERROR"
    print_status_secondary "ERROR" "fresh requires OS X"
    echo
    exit 1
  fi

  ## Business logic
  ## Credit: https://github.com/yellowducklabs/duckos/blob/master/duck#L85
  case "$1" in
    ## When $1 is a valid argument...
    "--"$VAR_VALID_ARGUMENTS)
      run_argument_${1#"--"}
    ;;

    ## When $1 is a valid command or argument...
    $VAR_VALID_COMMANDS)
    ## When $2 is a valid command argument or is not supplied...
    case "$2" in
      "--"$VAR_VALID_COMMAND_ARGUMENTS|"")
        run_command_$1 ${2#"--"} $3
      ;;
      *)
        print_input_error "$@"
      ;;
    esac
    ;;

    # When $1 is anything else...
    *)
      print_input_error "$@"
    ;;
  esac
}

## Run
run_argument_version() {
  print_version
}

run_argument_help() {
  print_help
}

run_command_init() {
  print_status_primary "INFO" "init"
  install_cli_tools
  install_homebrew
  install_git
  install_ansible
  install_fresh
  ansible_playbook "playbook.yml" "--tags=init"
  print_status_recap "PASS" "init"
  print_help
}

run_command_install() {
  print_status_primary "INFO" "install"
  ansible_playbook "playbook.yml" "--ask-become-pass --tags=install --skip-tags=${2}"
  print_status_recap "PASS" "install"
}

run_command_undo() {
  print_status_primary "INFO" "undo"
  ansible_playbook "playbook.yml" "--tags=undo,${1}"
  print_status_recap "PASS" "undo"
}

## Install
install_cli_tools() {
  if ! type_exists "gcc"; then
    ## Credit: https://github.com/boxen/boxen-web/blob/master/app/views/splash/script.sh.erb#L42-L63
    print_status_secondary "WARN" "Installing CLI tools for OS X"
    VAR_PLACEHOLDER=/tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    touch $VAR_PLACEHOLDER
    PROD=$(softwareupdate -l | \
      grep -B 1 "Command Line Tools" | \
      awk -F"*" '/^ +\*/ {print $2}' | \
      sed 's/^ *//' | \
      head -n 1)
    softwareupdate -i "${PROD}"
    [[ -f $VAR_PLACEHOLDER ]] && rm $VAR_PLACEHOLDER
  fi
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

install_homebrew() {
  if ! type_exists "brew"; then
    print_status_secondary "WARN" "Installing homebrew"
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
  fi
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

install_git() {
  if ! type_exists "git"; then
    print_status_secondary "WARN" "Installing git"
    brew install git
  fi
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

install_ansible() {
  if ! type_exists "ansible"; then
    print_status_secondary "WARN" "Installing ansible"
    brew install ansible
  fi
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

install_fresh() {
  if [ ! -d "${VAR_DIR}" ]; then
    print_status_secondary "WARN" "Cloning fresh"
    git clone --quiet https://github.com/d3v1an7/fresh.git $VAR_DIR
  fi
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

## Utilities
ansible_playbook() {
  print_status_secondary "WARN" "Running playbook"
  if [ -n "$1" ]; then VAR_ANSIBLE_PATH="${1}"; fi
  if [ -n "$2" ]; then VAR_ANSIBLE_EXTRAS="${2}"; fi
  cd ${VAR_DIR}/ansible && \
  ansible-playbook \
    "${VAR_ANSIBLE_PATH}" \
    --inventory-file="inventory/hosts" \
    ${VAR_ANSIBLE_EXTRAS}
  VAR_RECAP_ARRAY+=("${FUNCNAME}")
}

type_exists() {
  if [ $(type -P $1) ]; then
    return 0
  fi
  return 1
}

confirm() {
  # call with a prompt string or use a default
  read -r -p "${1:-Are you sure?} [y/n] " response
  echo
  case $response in
    [yY][eE][sS]|[yY])
      true
      ;;
    *)
      false
      ;;
  esac
}

## Output
print_logo() {
  VAR_COLOUR_LOGO="VAR_COLOUR_LOGO_${1}"
  printf "${!VAR_COLOUR_LOGO}%s${VAR_COLOUR_RESET}\n" "${2}"
}

print_status_primary() {
  VAR_COLOUR_PRIMARY="VAR_COLOUR_${1}"
  VAR_MESSAGE_PRIMARY="${2} "
  echo -en "${!VAR_COLOUR_PRIMARY}${VAR_MESSAGE_PRIMARY}"
  ## Asterisk line to match ansible style
  for ((i=0; i< (80 - ${#VAR_MESSAGE_PRIMARY}); i++)){
    echo -n "*";
  }
  echo -e "${VAR_COLOUR_RESET}"
  echo
}

print_status_secondary() {
  VAR_SECONDARY_COLOUR="VAR_COLOUR_${1}"
  VAR_SECONDARY_SYMBOL="VAR_SYMBOL_${1}"
  VAR_MESSAGE_SECONDARY="${2}"
  echo -e "${!VAR_SECONDARY_COLOUR}${!VAR_SECONDARY_SYMBOL}${VAR_COLOUR_RESET} ${VAR_MESSAGE_SECONDARY}"
}

print_status_recap() {
  print_status_primary "${1}" "${2} RECAP"
  for FUNCTION_NAME in ${VAR_RECAP_ARRAY[@]}; do
    print_status_secondary "PASS" "${FUNCTION_NAME}"
  done
  ## Reset array
  VAR_RECAP_ARRAY=()
  echo
}

print_input_error() {
  print_status_primary "ERROR" "ERROR"
  print_status_secondary "ERROR" "Invalid input: ${*-[null]}"
  echo
  print_help
}

print_version() {
  cd ${VAR_DIR}
  echo -ne "fresh: " && git rev-parse --short HEAD
  echo
  exit 1
}

print_help() {
  print_usage
  print_arguments
  exit 1
}

print_usage() {
  echo "usage: fresh [--version] [--help] <command> [<args>]"
  echo
}

print_arguments() {
  echo "Available commands are:"
  echo "    install  Installs applications and makes changes to system defaults"
  echo "    undo     Restores system to last known state"
  echo "    init     Ensures system has tools and apps required"
  echo
  echo "Optional flags for the INSTALL and UNDO commands:"
  echo "    --skip   Skips specified role [apps|defaults]"
  echo
}

## GLHF
init_fresh $@ ## Send all arguments to function
